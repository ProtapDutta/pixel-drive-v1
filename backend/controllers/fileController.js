// backend/controllers/fileController.js (FULL CODE WITH SORTING FIX)

import asyncHandler from 'express-async-handler';
import File from '../models/File.js';
import cloudinary from '../config/cloudinary.js';
import axios from 'axios';
import { decryptFile } from '../utils/encryption.js'; 

// --- UPLOAD CONTROLLER ---
// @desc Â  Â Upload multiple files to Cloudinary and save metadata
// @route Â  POST /api/files/upload
// @access Â Private
export const uploadFile = asyncHandler(async (req, res) => {
    
    // Expect an array of file details generated by the upload middleware
    const { fileDetailsList } = req.body; 
    const user = req.user._id;
    
    if (!fileDetailsList || fileDetailsList.length === 0) {
        res.status(400);
        throw new Error('No files processed for database entry.');
    }

    const documentsToInsert = [];
    
    // Fetch all existing file names for the current user to check for duplicates
    const existingFileNames = await File.find({ user }).select('fileName -_id');
    // Use a Set for fast lookup of existing names and names processed in the current batch
    let currentNames = new Set(existingFileNames.map(f => f.fileName));

    // Process each file for unique name and prepare for batch insert
    for (const details of fileDetailsList) {
        
        let finalFileName = details.fileName;
        
        // --- FILENAME UNIQUENESS LOGIC (Auto-incrementing) ---
        const parts = finalFileName.match(/(.*?)(?:\.([^.]+))?$/);
        const baseName = parts[1];
        const extension = parts[2] ? '.' + parts[2] : '';

        let counter = 0;
        let tempName = finalFileName;

        // Loop until a unique name is found
        while (currentNames.has(tempName)) {
            counter++;
            tempName = `${baseName} (${counter})${extension}`;
        }
        
        finalFileName = tempName;
        currentNames.add(finalFileName); // Ensure this name isn't reused by subsequent files in the batch
        // --- END FILENAME UNIQUENESS LOGIC ---
        
        // Create file record document
        documentsToInsert.push({
            user,
            fileName: finalFileName, // Use the final, unique name
            fileType: details.fileType,
            cloudinaryUrl: details.cloudinaryUrl,
            cloudinaryId: details.cloudinaryId,
            fileHash: details.fileHash,
            size: details.size,
            iv: details.iv, // Initialization Vector for decryption
            thumbnailUrl: details.thumbnailUrl,
            isEncrypted: true,
        });
    }

    // Save all files to the database in a single operation (faster than individual saves)
    const createdFiles = await File.insertMany(documentsToInsert);

    res.status(201).json({
        message: `${createdFiles.length} file(s) uploaded and saved successfully.`,
        files: createdFiles,
    });
});

// ----------------------------------------------------------------------------------

// --- FETCH CONTROLLER (FIXED FOR SORTING) ---
// @desc Â  Â Get all files for the authenticated user with pagination, search, and sorting
// @route Â  GET /api/files
// @access Â Private
export const getFiles = asyncHandler(async (req, res) => {
    // 1. Get parameters, ensuring page and limit are numbers with sensible defaults
    const { 
        search, 
        sortBy = 'createdAt', // ðŸ’¡ FIX: Extract sortBy with a default
        sortDirection = 'desc' // ðŸ’¡ FIX: Extract sortDirection with a default
    } = req.query;
    
    const page = parseInt(req.query.page) || 1; 
    const limit = parseInt(req.query.limit) || 20; 

    // Mongoose sort order mapping: 1 for ascending, -1 for descending
    const sortOrder = sortDirection === 'asc' ? 1 : -1;
    
    // 2. Establish the base query (filters by user)
    const query = { user: req.user._id };

    // 3. Add search filter if search term is provided
    if (search) {
        query.fileName = { $regex: search, $options: 'i' }; 
    }
    
    // 4. Get total count of files matching the query (before pagination)
    const totalCount = await File.countDocuments(query);
    
    // 5. Calculate skip value
    const skip = (page - 1) * limit;

    // 6. Fetch the paginated files with DYNAMIC sorting
    const files = await File.find(query)
        // ðŸ’¡ FIX: Use the extracted sortBy and sortOrder
        .sort({ [sortBy]: sortOrder }) 
        .skip(skip)
        .limit(limit);

    // 7. Return paginated data
    res.json({
        files,
        page,
        limit,
        totalCount,
        totalPages: Math.ceil(totalCount / limit),
    });
});

// ----------------------------------------------------------------------------------

// --- DOWNLOAD CONTROLLER ---
// @desc Â  Â Download and decrypt a file
// @route Â  GET /api/files/download/:id
// @access Â Private
export const downloadFile = asyncHandler(async (req, res) => {
    const file = await File.findById(req.params.id);

    if (!file) {
        res.status(404);
        throw new Error('File not found');
    }

    // Authorization check: Ensure the file belongs to the logged-in user
    if (file.user.toString() !== req.user.id) {
        res.status(401);
        throw new Error('Not authorized to download this file');
    }

    try {
        // 1. Fetch the encrypted file from Cloudinary (as a buffer)
        const response = await axios.get(file.cloudinaryUrl, {
            responseType: 'arraybuffer', // Crucial for handling binary data
        });

        const encryptedBuffer = Buffer.from(response.data);

        // 2. Decrypt the buffer
        const decryptedBuffer = decryptFile(encryptedBuffer, file.iv);

        // 3. Set headers for the download
        res.setHeader('Content-Type', file.fileType);
        res.setHeader('Content-Disposition', `attachment; filename="${file.fileName}"`);
        res.setHeader('Content-Length', decryptedBuffer.length);
        
        // 4. Send the decrypted file buffer
        res.send(decryptedBuffer);

    } catch (error) {
        console.error('Download/Decryption failed:', error);
        res.status(500);
        throw new Error('File download or decryption failed.');
    }
});

// ----------------------------------------------------------------------------------

// --- SINGLE DELETE CONTROLLER ---
// @desc Â  Â Delete a single file
// @route Â  DELETE /api/files/:id
// @access Â Private
export const deleteFile = asyncHandler(async (req, res) => {
    const file = await File.findById(req.params.id);

    if (!file) {
        res.status(404);
        throw new Error('File not found');
    }

    // Authorization check
    if (file.user.toString() !== req.user.id) {
        res.status(401);
        throw new Error('Not authorized to delete this file');
    }

    // 1. Delete from Cloudinary
    try {
        // Delete the main raw file
        await cloudinary.uploader.destroy(file.cloudinaryId, { resource_type: 'raw' });

        // If a thumbnail exists, delete it too
        if (file.thumbnailUrl) {
            // Reconstruct the public ID for the thumbnail: it's the main ID plus '-thumb'
            const thumbnailId = `${file.fileHash}-thumb`;
            await cloudinary.uploader.destroy(`file-storage-thumbnails/${req.user._id}/${thumbnailId}`, { resource_type: 'image' });
        }
    } catch (error) {
        console.error('Cloudinary deletion failed:', error);
        // We log the error but still proceed to delete the DB record
    }

    // 2. Delete from MongoDB
    await File.deleteOne({ _id: req.params.id });

    res.json({ message: 'File deleted successfully' });
});

// ----------------------------------------------------------------------------------

// --- MULTIPLE DELETE CONTROLLER ---
// @desc Â  Â Delete multiple files
// @route Â  POST /api/files/delete-many
// @access Â Private
export const deleteMultipleFiles = asyncHandler(async (req, res) => {
    const { fileIds } = req.body; // Expect an array of IDs

    if (!fileIds || fileIds.length === 0) {
        res.status(400);
        throw new Error('No file IDs provided for deletion.');
    }

    // 1. Find all files, ensuring they belong to the user
    const filesToDelete = await File.find({
        _id: { $in: fileIds },
        user: req.user._id,
    }).select('cloudinaryId fileHash thumbnailUrl');

    if (filesToDelete.length === 0) {
        res.status(404);
        throw new Error('No files found matching the provided IDs for this user.');
    }

    // 2. Collect Cloudinary public IDs for batch deletion
    const mainIds = filesToDelete.map(f => f.cloudinaryId);
    
    const thumbnailIds = filesToDelete
        .filter(f => f.thumbnailUrl)
        .map(f => `file-storage-thumbnails/${req.user._id}/${f.fileHash}-thumb`);

    // 3. Delete from Cloudinary in two batch operations
    try {
        if (mainIds.length > 0) {
            await cloudinary.api.delete_resources(mainIds, { resource_type: 'raw' });
        }

        if (thumbnailIds.length > 0) {
            await cloudinary.api.delete_resources(thumbnailIds, { resource_type: 'image' });
        }
        
    } catch (error) {
        console.error('Batch Cloudinary deletion failed:', error);
        // Log the error but continue to delete DB records
    }

    // 4. Delete from MongoDB
    const result = await File.deleteMany({ _id: { $in: fileIds }, user: req.user._id });

    res.json({ 
        message: `${result.deletedCount} file(s) deleted successfully.`,
        deletedCount: result.deletedCount,
    });
});


// ----------------------------------------------------------------------------------
// --- PUBLIC SHARING CONTROLLER: PERMANENT & DECRYPTED ---
// ----------------------------------------------------------------------------------

// @desc Â  Â View/Download a file using its permanent file ID
// @route Â  GET /api/files/public/share/:fileId
// @access Â Public (Unauthenticated)
export const getPublicSharedFile = asyncHandler(async (req, res) => {
    const fileId = req.params.fileId;

    // 1. Find the file by permanent ID
    const file = await File.findById(fileId);

    if (!file) {
        res.status(404);
        throw new Error('File not found or link is invalid.');
    }
    
    // NOTE: NO AUTHORIZATION CHECK - this is a public link.

    try {
        // 2. Fetch the encrypted file from Cloudinary 
        const response = await axios.get(file.cloudinaryUrl, {
            responseType: 'arraybuffer', // Crucial for handling binary data
        });

        const encryptedBuffer = Buffer.from(response.data);

        // 3. Decrypt the buffer
        const decryptedBuffer = decryptFile(encryptedBuffer, file.iv);

        // 4. Set headers for viewing (inline)
        // 'inline' attempts to display the file in the browser (e.g., images, PDFs)
        res.setHeader('Content-Type', file.fileType);
        res.setHeader('Content-Disposition', `inline; filename="${file.fileName}"`);
        res.setHeader('Content-Length', decryptedBuffer.length);
        
        // 5. Send the decrypted file buffer
        res.send(decryptedBuffer);
        
    } catch (error) {
        console.error('Sharing/Decryption failed:', error);
        res.status(500).send('File access failed. The file may be corrupt or inaccessible.');
    }
});

// ----------------------------------------------------------------------------------
// --- RENAME CONTROLLER ---
// ----------------------------------------------------------------------------------

// @desc Â  Â Rename a file and handle duplicate names
// @route Â  PUT /api/files/rename/:id
// @access Â Private
export const renameFile = asyncHandler(async (req, res) => {
    const fileId = req.params.id;
    let { newFileName } = req.body;
    
    if (!newFileName) {
        res.status(400);
        throw new Error('New file name is required.');
    }

    // 1. Find the file to be renamed and ensure ownership
    const file = await File.findById(fileId);

    if (!file) {
        res.status(404);
        throw new Error('File not found.');
    }

    if (file.user.toString() !== req.user.id) {
        res.status(401);
        throw new Error('Not authorized to rename this file.');
    }
    
    // Trim and normalize the filename
    newFileName = newFileName.trim();

    // 2. Extract base name and extension from the requested new name
    // Matches "basename.ext" or just "basename"
    const parts = newFileName.match(/(.*?)(?:\.([^.]+))?$/);
    let baseName = parts[1];
    const extension = parts[2] ? '.' + parts[2] : '';
    
    // Check if the name actually changed before proceeding
    if (newFileName === file.fileName) {
        return res.status(200).json({ 
            message: `File name is already "${file.fileName}". No change made.`, 
            file 
        });
    }

    // 3. Check for duplicates and auto-increment
    let finalFileName = newFileName;
    let counter = 0;
    
    // Find files belonging to the user with the same name, excluding the file being renamed
    let isDuplicate = await File.exists({ 
        user: req.user._id,
        fileName: finalFileName,
        _id: { $ne: fileId }
    });

    // Loop until a unique name is found
    while (isDuplicate) {
        counter++;
        finalFileName = `${baseName} (${counter})${extension}`;
        
        isDuplicate = await File.exists({ 
            user: req.user._id,
            fileName: finalFileName,
            _id: { $ne: fileId }
        });
    }

    // 4. Update the file name in the database
    file.fileName = finalFileName;
    const updatedFile = await file.save();

    res.json({ 
        message: `File successfully renamed to "${updatedFile.fileName}".`, 
        file: updatedFile 
    });
});